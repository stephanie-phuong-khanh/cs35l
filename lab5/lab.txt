1 and 2)

These two programs were written similarly. I accessed the command
line arguments 'to' and 'from' with arg[1] and arg[2] respectively.
I tested error conditions such too few or too many arguments, different
lengths of strings 'to' and 'from', and duplicate characters in the
'from' string.

I wrote a test file test.txt that contained several sentences, compiled
the programs, and tested them:

gcc -o tr2b tr2b.c
gcc -o tr2u tr2u.c

test #1: No arguments
./tr2b < test.txt
./tr2u < test.txt
Must have two string arguments.

test #2: Too many arguments
./tr2b 'a' 'b' 'c' < test.txt
./tr2u 'a' 'b' 'c' < test.txt
Must have two string arguments.

test #3: Different string lengths
./tr2b 'abc' 'xy' < test.txt
./tr2u 'abc' 'xy' < test.txt
Must have string arguments of same length.

test #4: Duplicate characters in 'from' string
./tr2b 'aab' 'xyz' < test.txt
./tr2u 'aab' 'xyz' < test.txt
Cannot have duplicate characters in from argument.

Empty file (outputs nothing)
touch empty.txt
./tr2b 'abc' 'xyz' < empty.txt
./tr2u 'abc' 'xyz' < empty.txt

Correct output for normal behavior
./tr2b 'abc' 'xyz' < test.txt
./tr2b 'abc' 'xyz' < test.txt



3)
I first create a dummy text file with 5000000 bytes using:
head --bytes=5000000 /dev/urandom > dummy.txt

I run strace when executing the tr2b and tr2u programs, saving
the output to a file, which contains one line per system call, so 
I will count the number of lines to find the number of system
calls made.

a) Writing to file and counting the lines in output file:

strace -o syscall_b ./tr2b 'abc' 'xyz' < dummy.txt > trash
strace -o syscall_u ./tr2u 'abc' 'xyz' < dummy.txt > trash

wc -l syscall_b
wc -l syscall_u

tr2b made 31 system calls, while tr2u made 9573874.

b) Writing to terminal:

strace -o syscall_b ./tr2b 'abc' 'xyz' < dummy.txt
strace -o syscall_u ./tr2u 'abc' 'xyz' < dummy.txt

wc -l syscall_b
wc -l syscall_u

Same behavior: tr2b made 33 system calls, while tr2u made 10000026.

In both tests, the tr2u program uses way more syscalls than tr2b 
does, which is expected because tr2u uses one read and one write syscall
for every character (~10 million for 5 million characters). The tr2b
program uses much fewer syscalls because it uses a buffer that allows
getchar and putchar (which are not system calls) can place and retrieve
characters respectively, so that the number of system calls is
significantly fewer.



4)
I run the time command to compare the amounts of time the two programs
take to run on the same file.

Outputting to file:
time ./tr2b 'abc' 'xyz' < dummy.txt > trash
real	0m0.021s
user	0m0.000s
sys	0m0.002s

time ./tr2u 'abc' 'xyz' < dummy.txt > trash
real	0m11.071s
user	0m1.373s
sys	0m9.491s

Writing to terminal:
time ./tr2b 'abc' 'xyz' < dummy.txt
real	0m0.002s
user	0m0.000s
sys	0m0.001s

time ./tr2u 'abc' 'xyz' < dummy.txt
real	0m9.286s
user	0m1.345s
sys	0m7.930s

When writing to terminal and to a file, tr2b uses much less time
than tr2u does. tr2u makes significantly more system calls as shown
in #3, and system calls entail much overhead: the current procress
is interrupted and computer saves its state, OS takes control of CPU
and sees if system call action is valid, performs the action, restores
the saved state, returns to user mode, and gives control back to user
process. tr2b's use of a buffer minimizes system calls, therefore 
significantly reducing the amount of time taken to execute the same action.